y[2] <- (1-t_s.0)*y[2]
return(y)
} # at the root, do this event
# Pars['th.0']
State = c(L_rF = 0, L_sF = 0.001, L_rL = 0, L_sL = 0, F_l = TR_TH$productivity[i], L_rW = 0, L_sW = F_w.0)
out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE))
# then take output from out and use to start new simulation state
State = out[dim(out)[1], 2:8]; State["L_sF"] = State["L_sF"]-0.001; State["L_rF"] = 0.001 # can just replace a suseptable louse with a resistant louse
out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE, maxroot = 6000))
out_df <- as.data.frame(out)
# get the last 30 days
out_last_month <- out_df[(length(Time)-30):length(Time), ]
resist_percent <- mean(out_last_month$L_rF/(out_last_month$L_rF + out_last_month$L_sF))
}}
# end parallel cluster
stopCluster(cl)
# manipulate dataframes
{
evol_dat <- TR_TH
evol_dat$value <- unlist(resist_percent_list)
}
# make figures
{fig4 <- ggplot(evol_dat, aes(thresh_val, value, col = as.factor(treat_eff))) +
geom_point(size = 1.4) +
facet_wrap(~type, nrow=2) +
scale_color_viridis(discrete = T, direction = -1) +  theme_classic() +
theme(legend.position = "bottom",
legend.title = element_text(size = 7),
legend.text = element_text(size = 7),
axis.title = element_text(size = 7),
axis.text = element_text(size = 7),
strip.text = element_text(size = 7)) +
labs(x = "Treatment threshold", y = "Proportion resistant", col = "Treatment efficacy")
}
fig4 # has some more efficacy options
F_w.0*2
save(econ_dat, "\simulated data\econ_dat.Rdata")
save(econ_dat, "/simulated data/econ_dat.Rdata")
getwd()
save(econ_dat, "simulated data/econ_dat.Rdata")
save(econ_dat, file = "/simulated data/econ_dat.Rdata")
save(econ_dat, file = "simulated data/econ_dat.Rdata")
save(econ_long, file = "simulated data/econ_long.Rdata")
save(outcome_vals, file = "simulated data/outcome_vals.Rdata")
save(link_size, "simulated data/link_size.Rdata")
save(link_size, file = "simulated data/link_size.Rdata")
save(evol_dat, file = "simulated data/evol_dat.Rdata")
Pars
# doing parallel
cl <- parallel::makeCluster(detectCores())
doParallel::registerDoParallel(cl)
# set up & make function
{tr.vec <- seq(from = 0.3, to = 0.9, length.out = 5) # treatment effect --> might be interesting to also do with wild fish to see how threshold & wild fish interact
th.vec <- seq(from = 0.01, to = 1.11, length.out = 11) # threshold
tr_th <- expand.grid(treat_eff = tr.vec, thresh_val = th.vec)
tr_th$connectivity <- rep(p_ff.0); tr_th$wildfish <- rep(F_w.0); tr_th$productivity <- rep(r.0); tr_th$type <- rep("base parameters")
tr_th_conn <- expand.grid(treat_eff = tr.vec, thresh_val = th.vec)
tr_th_conn$connectivity <- rep(p_ff.0-0.1); tr_th_conn$wildfish <- rep(F_w.0); tr_th_conn$productivity <- rep(r.0); tr_th_conn$type <- rep("increased connectivity")
tr_th_refg <- expand.grid(treat_eff = tr.vec, thresh_val = th.vec)
tr_th_refg$connectivity <- rep(p_ff.0); tr_th_refg$wildfish <- rep(F_w.0*2); tr_th_refg$productivity <- rep(r.0); tr_th_refg$type <- rep("increased refuge")
tr_th_prod <- expand.grid(treat_eff = tr.vec, thresh_val = th.vec)
tr_th_prod$connectivity <- rep(p_ff.0); tr_th_prod$wildfish <- rep(F_w.0); tr_th_prod$productivity <- rep(r.0*2); tr_th_prod$type <- rep("increased link productivity")
TR_TH <- rbind(tr_th, tr_th_conn, tr_th_refg, tr_th_prod)
# TR_TH <- rbind(tr_th)
# think about how to prep the foreach loop --> check how you did it in the evo rescue files?
resist_percent_list <- foreach(i=1:dim(TR_TH)[1], .packages="deSolve") %dopar% {
t_s.0 = TR_TH$treat_eff[i]
t_r.0 = t_s.0*0.05 # make 25% of t_s
p_ff.0 = TR_TH$connectivity[i] # low connectivity case (p_ff.0 close to 1)
p_ll.0 = p_ff.0 # lice in farm stay on farm...
p_fl.0 = 1-p_ff.0 # ...or jump to wild (spillover)
p_lf.0 = p_fl.0 # spillback rate
p_ww.0 = 1
Pars = base_pars
Pars['t_s'] <- t_s.0; Pars['t_r'] <- t_r.0
Pars['p_ff'] <- p_ff.0; Pars['p_ll'] <- p_ll.0; Pars['p_fl'] <- p_fl.0; Pars['p_lf'] <- p_lf.0; Pars['p_ww'] <- p_ww.0
Pars['r'] <- TR_TH$productivity[i]
F_w.0 <- TR_TH$wildfish[i]
Pars['F_w.0'] <- TR_TH$wildfish[i]
th.0 = TR_TH$thresh_val[i]
# redefine root & event with correct threshold and effecitivity
rootfunc <- function(Time, y, Pars) {return (y[1] + y[2] - th.0*F_f.0)} # threshold hit
eventfunc <- function(Time, y, Pars) {
y[1] <- (1-t_r.0)*y[1]
y[2] <- (1-t_s.0)*y[2]
return(y)
} # at the root, do this event
# Pars['th.0']
State = c(L_rF = 0, L_sF = 0.001, L_rL = 0, L_sL = 0, F_l = TR_TH$productivity[i], L_rW = 0, L_sW = F_w.0)
out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE))
# then take output from out and use to start new simulation state
State = out[dim(out)[1], 2:8]; State["L_sF"] = State["L_sF"]-0.001; State["L_rF"] = 0.001 # can just replace a suseptable louse with a resistant louse
out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE, maxroot = 6000))
out_df <- as.data.frame(out)
# get the last 30 days
out_last_month <- out_df[(length(Time)-30):length(Time), ]
resist_percent <- mean(out_last_month$L_rF/(out_last_month$L_rF + out_last_month$L_sF))
}}
# end parallel cluster
stopCluster(cl)
# manipulate dataframes
{
evol_dat <- TR_TH
evol_dat$value <- unlist(resist_percent_list)
}
save(evol_dat, file = "simulated data/evol_dat.Rdata")
# make figures
{fig4 <- ggplot(evol_dat, aes(thresh_val, value, col = as.factor(treat_eff))) +
geom_point(size = 1.4) +
facet_wrap(~type, nrow=2) +
scale_color_viridis(discrete = T, direction = -1) +  theme_classic() +
theme(legend.position = "bottom",
legend.title = element_text(size = 7),
legend.text = element_text(size = 7),
axis.title = element_text(size = 7),
axis.text = element_text(size = 7),
strip.text = element_text(size = 7)) +
labs(x = "Treatment threshold", y = "Proportion resistant", col = "Treatment efficacy")
}
fig4 # has some more efficacy options
View(evol_dat)
F_w.0/10
rep(F_w.0/20)
# doing parallel
cl <- parallel::makeCluster(detectCores())
doParallel::registerDoParallel(cl)
# set up & make function
{tr.vec <- seq(from = 0.3, to = 0.9, length.out = 5) # treatment effect --> might be interesting to also do with wild fish to see how threshold & wild fish interact
th.vec <- seq(from = 0.01, to = 1.11, length.out = 11) # threshold
tr_th <- expand.grid(treat_eff = tr.vec, thresh_val = th.vec)
tr_th$connectivity <- rep(p_ff.0); tr_th$wildfish <- rep(F_w.0/20); tr_th$productivity <- rep(r.0); tr_th$type <- rep("base parameters")
tr_th_conn <- expand.grid(treat_eff = tr.vec, thresh_val = th.vec)
tr_th_conn$connectivity <- rep(p_ff.0-0.1); tr_th_conn$wildfish <- rep(F_w.0); tr_th_conn$productivity <- rep(r.0); tr_th_conn$type <- rep("increased connectivity")
tr_th_refg <- expand.grid(treat_eff = tr.vec, thresh_val = th.vec)
tr_th_refg$connectivity <- rep(p_ff.0); tr_th_refg$wildfish <- rep(F_w.0*2); tr_th_refg$productivity <- rep(r.0); tr_th_refg$type <- rep("increased refuge")
tr_th_prod <- expand.grid(treat_eff = tr.vec, thresh_val = th.vec)
tr_th_prod$connectivity <- rep(p_ff.0); tr_th_prod$wildfish <- rep(F_w.0); tr_th_prod$productivity <- rep(r.0*2); tr_th_prod$type <- rep("increased link productivity")
# TR_TH <- rbind(tr_th, tr_th_conn, tr_th_refg, tr_th_prod)
TR_TH <- rbind(tr_th)
# think about how to prep the foreach loop --> check how you did it in the evo rescue files?
resist_percent_list <- foreach(i=1:dim(TR_TH)[1], .packages="deSolve") %dopar% {
t_s.0 = TR_TH$treat_eff[i]
t_r.0 = t_s.0*0.05 # make 25% of t_s
p_ff.0 = TR_TH$connectivity[i] # low connectivity case (p_ff.0 close to 1)
p_ll.0 = p_ff.0 # lice in farm stay on farm...
p_fl.0 = 1-p_ff.0 # ...or jump to wild (spillover)
p_lf.0 = p_fl.0 # spillback rate
p_ww.0 = 1
Pars = base_pars
Pars['t_s'] <- t_s.0; Pars['t_r'] <- t_r.0
Pars['p_ff'] <- p_ff.0; Pars['p_ll'] <- p_ll.0; Pars['p_fl'] <- p_fl.0; Pars['p_lf'] <- p_lf.0; Pars['p_ww'] <- p_ww.0
Pars['r'] <- TR_TH$productivity[i]
F_w.0 <- TR_TH$wildfish[i]
Pars['F_w.0'] <- TR_TH$wildfish[i]
th.0 = TR_TH$thresh_val[i]
# redefine root & event with correct threshold and effecitivity
rootfunc <- function(Time, y, Pars) {return (y[1] + y[2] - th.0*F_f.0)} # threshold hit
eventfunc <- function(Time, y, Pars) {
y[1] <- (1-t_r.0)*y[1]
y[2] <- (1-t_s.0)*y[2]
return(y)
} # at the root, do this event
# Pars['th.0']
State = c(L_rF = 0, L_sF = 0.001, L_rL = 0, L_sL = 0, F_l = TR_TH$productivity[i], L_rW = 0, L_sW = F_w.0)
out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE))
# then take output from out and use to start new simulation state
State = out[dim(out)[1], 2:8]; State["L_sF"] = State["L_sF"]-0.001; State["L_rF"] = 0.001 # can just replace a suseptable louse with a resistant louse
out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE, maxroot = 6000))
out_df <- as.data.frame(out)
# get the last 30 days
out_last_month <- out_df[(length(Time)-30):length(Time), ]
resist_percent <- mean(out_last_month$L_rF/(out_last_month$L_rF + out_last_month$L_sF))
}}
# end parallel cluster
stopCluster(cl)
# manipulate dataframes
{
evol_dat <- TR_TH
evol_dat$value <- unlist(resist_percent_list)
}
# save(evol_dat, file = "simulated data/evol_dat.Rdata")
# make figures
{fig4 <- ggplot(evol_dat, aes(thresh_val, value, col = as.factor(treat_eff))) +
geom_point(size = 1.4) +
facet_wrap(~type, nrow=2) +
scale_color_viridis(discrete = T, direction = -1) +  theme_classic() +
theme(legend.position = "bottom",
legend.title = element_text(size = 7),
legend.text = element_text(size = 7),
axis.title = element_text(size = 7),
axis.text = element_text(size = 7),
strip.text = element_text(size = 7)) +
labs(x = "Treatment threshold", y = "Proportion resistant", col = "Treatment efficacy")
}
fig4 # has some more efficacy options
F_w.0
View(TR_TH)
###########################################################
l_s.0 = 1; c_s.0 = 1 # l_s.0 = 1
# l_r.0 = 1; c_r.0 = 1
l_r.0 = 0.95*l_s.0; c_r.0 = 1 # similar to Murray values
u_s.0 = .1
u_r.0 = .1 # Bateman et al modifies resistant lice here
m.0 = 1; mb.0 = 1
p_ff.0 = 0.9 # low connectivity case (p_ff.0 close to 1)
p_ll.0 = p_ff.0 # lice in farm stay on farm...
p_fl.0 = 1-p_ff.0 # ...or jump to wild (spillover)
p_lf.0 = p_fl.0 # spillback rate
p_ww.0 = 1 # all lice in wild stay in that environment
B_f.0 = 1 # all the lice attach type vibe
B_l.0 = 0.75 # slightly lower in the link population -- bateman vibe
B_w.0 = 0.25 # lowest in wild
t_s.0 = 0.9
t_r.0 = t_s.0*0.1 # similar to Murray
th.0 = 10 # Murray/Bateman: continous treatment
h.0 = 0.1
F_f.0 = 1 # normalize farm fish population size
F_w.0 = 5 # I think this is right?
r.0 = 1.5
v.0 = 1
X.0 = 0.4 # parasite induced mortality
Y.0 = 0.1 # 0.1
u_f.0 = 0
M_out.0 = 0.2
M_in.0 = 0.1
sig.0 = 0.5
n = 365
Time = seq(0, 5*n, length.out = 5*n+1)
base_pars = c(l_s = l_s.0, c_s = c_s.0, l_r = l_r.0, c_r = c_r.0,
u_s = u_s.0, u_r = u_r.0, m = m.0, mb = mb.0,
p_ff = p_ff.0, p_ll = p_ll.0, p_fl = p_fl.0, p_lf = p_lf.0, p_ww = p_ww.0,
B_f = B_f.0, B_l = B_l.0, B_w = B_w.0,
t_r = t_r.0, t_s = t_s.0, th = th.0, h = h.0,
F_f = F_f.0, F_w = F_w.0,
r = r.0, v = v.0, X = X.0, Y = Y.0, u_f = u_f.0, sig = sig.0,
M_out = M_out.0, M_in = M_in.0)
cl <- parallel::makeCluster(detectCores())
doParallel::registerDoParallel(cl)
# set up & make function
{tr.vec <- seq(from = 0.3, to = 0.9, length.out = 5) # treatment effect --> might be interesting to also do with wild fish to see how threshold & wild fish interact
th.vec <- seq(from = 0.01, to = 1.11, length.out = 11) # threshold
tr_th <- expand.grid(treat_eff = tr.vec, thresh_val = th.vec)
tr_th$connectivity <- rep(p_ff.0); tr_th$wildfish <- rep(F_w.0/20); tr_th$productivity <- rep(r.0); tr_th$type <- rep("base parameters")
tr_th_conn <- expand.grid(treat_eff = tr.vec, thresh_val = th.vec)
tr_th_conn$connectivity <- rep(p_ff.0-0.1); tr_th_conn$wildfish <- rep(F_w.0); tr_th_conn$productivity <- rep(r.0); tr_th_conn$type <- rep("increased connectivity")
tr_th_refg <- expand.grid(treat_eff = tr.vec, thresh_val = th.vec)
tr_th_refg$connectivity <- rep(p_ff.0); tr_th_refg$wildfish <- rep(F_w.0*2); tr_th_refg$productivity <- rep(r.0); tr_th_refg$type <- rep("increased refuge")
tr_th_prod <- expand.grid(treat_eff = tr.vec, thresh_val = th.vec)
tr_th_prod$connectivity <- rep(p_ff.0); tr_th_prod$wildfish <- rep(F_w.0); tr_th_prod$productivity <- rep(r.0*2); tr_th_prod$type <- rep("increased link productivity")
# TR_TH <- rbind(tr_th, tr_th_conn, tr_th_refg, tr_th_prod)
TR_TH <- rbind(tr_th)
# think about how to prep the foreach loop --> check how you did it in the evo rescue files?
resist_percent_list <- foreach(i=1:dim(TR_TH)[1], .packages="deSolve") %dopar% {
t_s.0 = TR_TH$treat_eff[i]
t_r.0 = t_s.0*0.05 # make 25% of t_s
p_ff.0 = TR_TH$connectivity[i] # low connectivity case (p_ff.0 close to 1)
p_ll.0 = p_ff.0 # lice in farm stay on farm...
p_fl.0 = 1-p_ff.0 # ...or jump to wild (spillover)
p_lf.0 = p_fl.0 # spillback rate
p_ww.0 = 1
Pars = base_pars
Pars['t_s'] <- t_s.0; Pars['t_r'] <- t_r.0
Pars['p_ff'] <- p_ff.0; Pars['p_ll'] <- p_ll.0; Pars['p_fl'] <- p_fl.0; Pars['p_lf'] <- p_lf.0; Pars['p_ww'] <- p_ww.0
Pars['r'] <- TR_TH$productivity[i]
F_w.0 <- TR_TH$wildfish[i]
Pars['F_w.0'] <- TR_TH$wildfish[i]
th.0 = TR_TH$thresh_val[i]
# redefine root & event with correct threshold and effecitivity
rootfunc <- function(Time, y, Pars) {return (y[1] + y[2] - th.0*F_f.0)} # threshold hit
eventfunc <- function(Time, y, Pars) {
y[1] <- (1-t_r.0)*y[1]
y[2] <- (1-t_s.0)*y[2]
return(y)
} # at the root, do this event
# Pars['th.0']
State = c(L_rF = 0, L_sF = 0.001, L_rL = 0, L_sL = 0, F_l = TR_TH$productivity[i], L_rW = 0, L_sW = TR_TH$wildfish[i])
out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE))
# then take output from out and use to start new simulation state
State = out[dim(out)[1], 2:8]; State["L_sF"] = State["L_sF"]-0.001; State["L_rF"] = 0.001 # can just replace a suseptable louse with a resistant louse
out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE, maxroot = 6000))
out_df <- as.data.frame(out)
# get the last 30 days
out_last_month <- out_df[(length(Time)-30):length(Time), ]
resist_percent <- mean(out_last_month$L_rF/(out_last_month$L_rF + out_last_month$L_sF))
}}
# end parallel cluster
stopCluster(cl)
# manipulate dataframes
{
evol_dat <- TR_TH
evol_dat$value <- unlist(resist_percent_list)
}
# save(evol_dat, file = "simulated data/evol_dat.Rdata")
# make figures
{fig4 <- ggplot(evol_dat, aes(thresh_val, value, col = as.factor(treat_eff))) +
geom_point(size = 1.4) +
facet_wrap(~type, nrow=2) +
scale_color_viridis(discrete = T, direction = -1) +  theme_classic() +
theme(legend.position = "bottom",
legend.title = element_text(size = 7),
legend.text = element_text(size = 7),
axis.title = element_text(size = 7),
axis.text = element_text(size = 7),
strip.text = element_text(size = 7)) +
labs(x = "Treatment threshold", y = "Proportion resistant", col = "Treatment efficacy")
}
fig4 # has some mor
###########################################################
l_s.0 = 1; c_s.0 = 1 # l_s.0 = 1
# l_r.0 = 1; c_r.0 = 1
l_r.0 = 0.95*l_s.0; c_r.0 = 1 # similar to Murray values
u_s.0 = .1
u_r.0 = .1 # Bateman et al modifies resistant lice here
m.0 = 1; mb.0 = 1
p_ff.0 = 0.9 # low connectivity case (p_ff.0 close to 1)
p_ll.0 = p_ff.0 # lice in farm stay on farm...
p_fl.0 = 1-p_ff.0 # ...or jump to wild (spillover)
p_lf.0 = p_fl.0 # spillback rate
p_ww.0 = 1 # all lice in wild stay in that environment
B_f.0 = 1 # all the lice attach type vibe
B_l.0 = 0.75 # slightly lower in the link population -- bateman vibe
B_w.0 = 0.25 # lowest in wild
t_s.0 = 0.9
t_r.0 = t_s.0*0.1 # similar to Murray
th.0 = 10 # Murray/Bateman: continous treatment
h.0 = 0.1
F_f.0 = 1 # normalize farm fish population size
F_w.0 = 5 # I think this is right?
r.0 = 1.5
v.0 = 1
X.0 = 0.4 # parasite induced mortality
Y.0 = 0.1 # 0.1
u_f.0 = 0
M_out.0 = 0.2
M_in.0 = 0.1
sig.0 = 0.5
n = 365
Time = seq(0, 5*n, length.out = 5*n+1)
base_pars = c(l_s = l_s.0, c_s = c_s.0, l_r = l_r.0, c_r = c_r.0,
u_s = u_s.0, u_r = u_r.0, m = m.0, mb = mb.0,
p_ff = p_ff.0, p_ll = p_ll.0, p_fl = p_fl.0, p_lf = p_lf.0, p_ww = p_ww.0,
B_f = B_f.0, B_l = B_l.0, B_w = B_w.0,
t_r = t_r.0, t_s = t_s.0, th = th.0, h = h.0,
F_f = F_f.0, F_w = F_w.0,
r = r.0, v = v.0, X = X.0, Y = Y.0, u_f = u_f.0, sig = sig.0,
M_out = M_out.0, M_in = M_in.0)
F_w.0/50
base_pars
# doing parallel
cl <- parallel::makeCluster(detectCores())
doParallel::registerDoParallel(cl)
# set up & make function
{tr.vec <- seq(from = 0.3, to = 0.9, length.out = 2) # treatment effect --> might be interesting to also do with wild fish to see how threshold & wild fish interact
th.vec <- seq(from = 0.01, to = 1.11, length.out = 6) # threshold
tr_th <- expand.grid(treat_eff = tr.vec, thresh_val = th.vec)
tr_th$connectivity <- rep(p_ff.0); tr_th$wildfish <- rep(F_w.0); tr_th$productivity <- rep(r.0); tr_th$type <- rep("base parameters")
tr_th_conn <- expand.grid(treat_eff = tr.vec, thresh_val = th.vec)
tr_th_conn$connectivity <- rep(p_ff.0-0.1); tr_th_conn$wildfish <- rep(F_w.0); tr_th_conn$productivity <- rep(r.0); tr_th_conn$type <- rep("increased connectivity")
tr_th_refg <- expand.grid(treat_eff = tr.vec, thresh_val = th.vec)
tr_th_refg$connectivity <- rep(p_ff.0); tr_th_refg$wildfish <- rep(F_w.0*2); tr_th_refg$productivity <- rep(r.0); tr_th_refg$type <- rep("increased refuge")
tr_th_prod <- expand.grid(treat_eff = tr.vec, thresh_val = th.vec)
tr_th_prod$connectivity <- rep(p_ff.0); tr_th_prod$wildfish <- rep(F_w.0); tr_th_prod$productivity <- rep(r.0*2); tr_th_prod$type <- rep("increased link productivity")
# TR_TH <- rbind(tr_th, tr_th_conn, tr_th_refg, tr_th_prod)
TR_TH <- rbind(tr_th, tr_th_refg)
# think about how to prep the foreach loop --> check how you did it in the evo rescue files?
resist_percent_list <- foreach(i=1:dim(TR_TH)[1], .packages="deSolve") %dopar% {
t_s.0 = TR_TH$treat_eff[i]
t_r.0 = t_s.0*0.05 # make 25% of t_s
p_ff.0 = TR_TH$connectivity[i] # low connectivity case (p_ff.0 close to 1)
p_ll.0 = p_ff.0 # lice in farm stay on farm...
p_fl.0 = 1-p_ff.0 # ...or jump to wild (spillover)
p_lf.0 = p_fl.0 # spillback rate
p_ww.0 = 1
Pars = base_pars
Pars['t_s'] <- t_s.0; Pars['t_r'] <- t_r.0
Pars['p_ff'] <- p_ff.0; Pars['p_ll'] <- p_ll.0; Pars['p_fl'] <- p_fl.0; Pars['p_lf'] <- p_lf.0; Pars['p_ww'] <- p_ww.0
Pars['r'] <- TR_TH$productivity[i]
F_w.0 <- TR_TH$wildfish[i]
Pars['F_w'] <- TR_TH$wildfish[i]
th.0 = TR_TH$thresh_val[i]
# redefine root & event with correct threshold and effecitivity
rootfunc <- function(Time, y, Pars) {return (y[1] + y[2] - th.0*F_f.0)} # threshold hit
eventfunc <- function(Time, y, Pars) {
y[1] <- (1-t_r.0)*y[1]
y[2] <- (1-t_s.0)*y[2]
return(y)
} # at the root, do this event
# Pars['th.0']
State = c(L_rF = 0, L_sF = 0.001, L_rL = 0, L_sL = 0, F_l = TR_TH$productivity[i], L_rW = 0, L_sW = TR_TH$wildfish[i])
out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE))
# then take output from out and use to start new simulation state
State = out[dim(out)[1], 2:8]; State["L_sF"] = State["L_sF"]-0.001; State["L_rF"] = 0.001 # can just replace a suseptable louse with a resistant louse
out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE, maxroot = 6000))
out_df <- as.data.frame(out)
# get the last 30 days
out_last_month <- out_df[(length(Time)-30):length(Time), ]
resist_percent <- mean(out_last_month$L_rF/(out_last_month$L_rF + out_last_month$L_sF))
}}
# end parallel cluster
stopCluster(cl)
# manipulate dataframes
{
evol_dat <- TR_TH
evol_dat$value <- unlist(resist_percent_list)
}
# make figures
{fig4 <- ggplot(evol_dat, aes(thresh_val, value, col = as.factor(treat_eff))) +
geom_point(size = 1.4) +
facet_wrap(~type, nrow=2) +
scale_color_viridis(discrete = T, direction = -1) +  theme_classic() +
theme(legend.position = "bottom",
legend.title = element_text(size = 7),
legend.text = element_text(size = 7),
axis.title = element_text(size = 7),
axis.text = element_text(size = 7),
strip.text = element_text(size = 7)) +
labs(x = "Treatment threshold", y = "Proportion resistant", col = "Treatment efficacy")
}
fig4 # ha
View(TR_TH)
l_s.0 = 1; c_s.0 = 1 # l_s.0 = 1
# l_r.0 = 1; c_r.0 = 1
l_r.0 = 0.95*l_s.0; c_r.0 = 1 # similar to Murray values
u_s.0 = .1
u_r.0 = .1 # Bateman et al modifies resistant lice here
m.0 = 1; mb.0 = 1
p_ff.0 = 0.95 # low connectivity case (p_ff.0 close to 1)
p_ll.0 = p_ff.0 # lice in farm stay on farm...
p_fl.0 = 1-p_ff.0 # ...or jump to wild (spillover)
p_lf.0 = p_fl.0 # spillback rate
p_ww.0 = 1 # all lice in wild stay in that environment
B_f.0 = 1 # all the lice attach type vibe
B_l.0 = 0.75 # slightly lower in the link population -- bateman vibe
B_w.0 = 0.25 # lowest in wild
t_s.0 = 0.9
t_r.0 = t_s.0*0.1 # similar to Murray
th.0 = 10 # Murray/Bateman: continous treatment
h.0 = 0.1
F_f.0 = 1 # normalize farm fish population size
F_w.0 = 5 # I think this is right?
r.0 = 1.5
v.0 = 1
X.0 = 0.4 # parasite induced mortality
Y.0 = 0.1 # 0.1
u_f.0 = 0
M_out.0 = 0.2
M_in.0 = 0.1
sig.0 = 0.5
n = 365
Time = seq(0, 5*n, length.out = 5*n+1)
base_pars = c(l_s = l_s.0, c_s = c_s.0, l_r = l_r.0, c_r = c_r.0,
u_s = u_s.0, u_r = u_r.0, m = m.0, mb = mb.0,
p_ff = p_ff.0, p_ll = p_ll.0, p_fl = p_fl.0, p_lf = p_lf.0, p_ww = p_ww.0,
B_f = B_f.0, B_l = B_l.0, B_w = B_w.0,
t_r = t_r.0, t_s = t_s.0, th = th.0, h = h.0,
F_f = F_f.0, F_w = F_w.0,
r = r.0, v = v.0, X = X.0, Y = Y.0, u_f = u_f.0, sig = sig.0,
M_out = M_out.0, M_in = M_in.0)
#----figure 2: economic outcomes----
# using base parameters
# set up & make function
{
tr.vec <- tr.vec <- seq(from = 0.3, to = 0.9, length.out = 5) # treatment effect --> might be interesting to also do with wild fish to see how threshold & wild fish interact
th.vec <- seq(from = 0.01, to = 1.11, length.out = 11) # threshold
# tr.vec <- c(0.35, 0.55, 0.75, 0.95) # treatment effect --> might be interesting to also do with wild fish to see how threshold & wild fish interact
# th.vec <- c(0.0015, 1:18) # threshold
# lossesF1_mat <- matrix(NA, nrow = length(th.vec), ncol = length(tr.vec))
treat_num <- matrix(NA, nrow = length(th.vec), ncol = length(tr.vec))
lice_burd <- matrix(NA, nrow = length(th.vec), ncol = length(tr.vec))
link_pop <- matrix(NA, nrow = length(th.vec), ncol = length(tr.vec))
State = NA # dummy parameter for running?
outcomes_ecol_econ <- function() {
for (i in 1:length(tr.vec)) {
t_s.0 = tr.vec[i]
t_r.0 = t_s.0*0.05 # make 25% of t_s
for (j in 1:length(th.vec)) {
th.0 = th.vec[j]
# print(c(i, j))
# redefine root & event with correct threshold and effecitivity
rootfunc <- function(Time, y, Pars) {return (y[1] + y[2] - th.0*F_f.0)} # threshold hit
eventfunc <- function(Time, y, Pars) {
y[1] <- (1-t_r.0)*y[1]
y[2] <- (1-t_s.0)*y[2]
return(y)
} # at the root, do this event
Pars = base_pars
Pars['t_s'] <- t_s.0
Pars['t_r'] <- t_r.0
State = c(L_rF = 0, L_sF = 0.001, L_rL = 0, L_sL = 0, F_l = r.0, L_rW = 0, L_sW = F_w.0)
out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE))
# then take output from out and use to start new simulation state
State = out[dim(out)[1], 2:8]; State["L_sF"] = State["L_sF"]-0.001; State["L_rF"] = 0.001 # can just replace a suseptable louse with a resistant louse
Time_invade = seq(0, 5*n-31, length.out = 5*n-30)
out <- ode(Time_invade, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE))
Time_outs = seq(0, 30, length.out = 31) # simulate just last month
State = out[dim(out)[1], 2:8]
out <- ode(Time_outs, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE, maxroots = 20000))
# just last month of things
out_df <- as.data.frame(out) # %>% filter(time > (max(Time)-31))
treat_time <- attributes(out)$troot
treat_apply <- length(treat_time) # (which(treat_time > (max(Time)-31)))
treat_num[j,i] <- treat_apply
lice_burd[j,i] <- sum(out_df$L_rF + out_df$L_sF) # bc this is the sum of two lists
link_pop[j, i] <- mean(out_df$F_l)
}
}
return(list(treat_num, lice_burd, link_pop))
}}
# run econ function
{
outcome_vals <- outcomes_ecol_econ()
}
