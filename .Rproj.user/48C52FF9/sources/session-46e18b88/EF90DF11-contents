---
title: "farm invasion with thrshold"
author: "Laurie Balstad"
date: "2023-03-15"
output: html_document
---

```{r setup, include=FALSE}

knitr::opts_chunk$set(echo = TRUE)
library(deSolve)
library(dplyr)
library(matlib)
library(sparsevar) 
library(randomForest)
library(lhs)
library(reshape2)
library(ggplot2)
library(RColorBrewer)
library(viridis)
library(MetBrewer)
library(cowplot)

```

## parameters!

```{r normalized parameters}

l_s.0 = 1; c_s.0 = 1
# l_r.0 = 1; c_r.0 = 1
l_r.0 = 0.9; c_r.0 = 1 # similar to Murray values
u_s.0 = .1
u_r.0 = .1 # Bateman et al modifies resistant lice here
m.0 = 1; mb.0 = 1

p_ff.0 = 0.95 # low connectivity case (p_ff.0 close to 1)
p_ll.0 = p_ff.0 # lice in farm stay on farm...
p_fl.0 = 1-p_ff.0 # ...or jump to wild (spillover)
p_lf.0 = p_fl.0 # spillback rate
p_ww.0 = 1 # all lice in wild stay in that environment
B_f.0 = 1 # all the lice attach type vibe
B_l.0 = 0.5 # slightly lower in the link population -- bateman vibe
B_w.0 = 0.1 # lowest in wild

t_r.0 = 0.05 # similar to Murray
t_s.0 = 0.9
th.0 = 0.01 # Murray/Bateman: continous treatment
h.0 = 0.1

F_f.0 = 1 # normalize farm fish population size
F_w.0 = 6 # I think this is right?
r.0 = 1
v.0 = 1
X.0 = 0.25 # 0.4
Y.0 = 0.25 # 0.1
u_f.0 = 0.25
M_out.0 = 0.2
M_in.0 = 0.1
sig.0 = 0.5

n = 150 
Time = seq(0, n, length.out = 5*n)

```

```{r daily parameters}

l_s.0 = 6.35; c_s.0 = 1/5 # note magnitude change from bateman --> bc B_f/p_ff and B_ff are different??
# l_r.0 = 1; c_r.0 = 1
l_r.0 = l_s.0*0.9; c_r.0 = c_s.0 # similar to Murray values: l_s.0*0.98
u_s.0 = 1/60
u_r.0 = u_s.0 # Bateman et al modifies resistant lice here
m.0 = 0.01 # try diff values? 0.001 gives ~160 equilibrium
mb.0 = 0.01 # 1?? 0.2??

p_ff.0 = 0.95 # low connectivity case (p_ff.0 close to 1) -- moving to 0.9 helps demonstrate more realistic scenarios
p_ll.0 = p_ff.0 # lice in farm stay on farm...
p_fl.0 = 1-p_ff.0 # ...or jump to wild (spillover)
p_lf.0 = p_fl.0 # spillback rate
p_ww.0 = 1 # all lice in wild stay in that environment
B_f.0 = 0.22*5.9*10^-9/1.3 # 0.22*5.9*10^-10/1.3 # all the lice attach type vibe magnitude appoximation
B_l.0 = B_f.0/2 # B_f.0*0.5 # slightly lower in the link population -- bateman vibe
B_w.0 = B_f.0/10 # lowest in wild

Tr.0 = 3 # just to start
t_s.0 = 0.9 # 95% effective
t_r.0 = t_s.0*0.25 # 15% effective
b.0 = 1000
th.0 = 0 # Murray/Bateman: continous treatment
h.0 = 0.67/365

F_f.0 = 6*10^6 # normalize farm fish population size --> might need to be closer to 2e6?? for about a single farm v. whole network
F_w.0 = 10*F_f.0
r.0 = 1.2*10^2 # 5.2*10^3
v.0 = 1*10^2 # 1*10^2
X.0 = 0.02
u_f.0 = 0 # bateman has no fish death
M_out.0 = 1/(0.25*365)
Y.0 = M_out.0
M_in.0 = 1/(1.25*365)
sig.0 = 1/(0.25*365)

pT.0 = 10
pQ.0 = 2

n = 365*5 # for daily bateman pars --> 10 years
Time = seq(0, n, length.out = n/2)

```

## model

```{r add discontinuity}

systemTREAT <- function (Time, y, Pars) {
    with(as.list(c(State, Pars)), {
       
        # domestic parasites
        dy1 = ifelse(y[1] <= 0, 0, l_r/c_r*F_f*B_f*(p_ff*y[1] + p_fl*(M_out*y[5]*y[6])/((F_w+M_out*y[5]/M_in)*(u_r + sig))) - (u_r+h)*y[1] - m*y[1]*(y[1] + y[2])/F_f)
        dy2 = ifelse(y[2] <= 0, 0, l_s/c_s*F_f*B_f*(p_ff*y[2] + p_fl*(M_out*y[5]*y[7])/((F_w+M_out*y[5]/M_in)*(u_s + sig))) - (u_s+h)*y[2] - m*y[2]*(y[1] + y[2])/F_f)
        
        # domesitc hosts in equilibirum
      
        # link parasites
        dy3 = l_r/c_r*y[5]*B_l*(p_lf*y[1]) - (u_r+Y+M_out+X)*y[3] - X*y[3]*(y[3]+y[4])/y[5]
        dy4 = l_s/c_s*y[5]*B_l*(p_lf*y[2]) - (u_s+Y+M_out+X)*y[4] - X*y[4]*(y[3]+y[4])/y[5]
        # dy3 = l_r/c_r*y[5]*B_l*(p_ll*y[3] + p_lf*y[1]) - (u_r+Y+M_out+X)*y[3] - X*y[3]*(y[3]+y[4])/y[5]
        # dy4 = l_s/c_s*y[5]*B_l*(p_ll*y[4] + p_lf*y[2]) - (u_s+Y+M_out+X)*y[4] - X*y[4]*(y[3]+y[4])/y[5]
        
        # link hosts
        dy5 = r*y[5]/(v+y[5]) - X*(y[3] + y[4]) - Y*y[5] - M_out*y[5] # hosts leave by maturing
        
        # wild subsidy
        dy6 = l_r/c_r*B_w*(F_w + (M_out*y[5]/M_in))*p_ww*y[6] + M_out*y[3] - (u_r+u_f)*y[6] - M_out*y[5]*y[6]/(F_w + (M_out*y[5]/M_in)) - mb*y[6]*(y[6]+y[7])/(F_w + (M_out*y[5]/M_in))
        dy7 = l_s/c_s*B_w*(F_w + (M_out*y[5]/M_in))*p_ww*y[7] + M_out*y[4] - (u_s+u_f)*y[7] - M_out*y[5]*y[7]/(F_w + (M_out*y[5]/M_in)) - mb*y[7]*(y[6]+y[7])/(F_w + (M_out*y[5]/M_in))
        
        # wild hosts, spawning hosts & spawning parasites in equilbiribum
        
        derivs = c(dy1, dy2, dy3, dy4, dy5, dy6, dy7)
        
        derivs[!is.finite(derivs)] = 0
        
        return(list(derivs))
    })
}

eventfunc <- function(Time, y, Pars) {
  y[1] <- (1-t_r.0)*y[1]
  y[2] <- (1-t_s.0)*y[2]
  return(y)
}

rootfunc <- function(Time, y, Pars) {return (y[1] + y[2] - th.0*F_f.0)}

# Pars = c(l_s = l_s.0, c_s = c_s.0, l_r = l_r.0, c_r = c_r.0,
#          u_s = u_s.0, u_r = u_r.0, m = m.0, mb = mb.0,
#          p_ff = p_ff.0, p_ll = p_ll.0, p_fl = p_fl.0, p_lf = p_lf.0, p_ww = p_ww.0,
#          B_f = B_f.0, B_l = B_l.0, B_w = B_w.0,
#          t_r = t_r.0, t_s = t_s.0, th = th.0, h = h.0,
#          F_f = F_f.0, F_w = F_w.0,
#          r = r.0, v = v.0, X = X.0, Y = Y.0, u_f = u_f.0, sig = sig.0,
#          M_out = M_out.0, M_in = M_in.0)
# # 
# State = c(L_rF = 0, L_sF = 0.001, L_rL = 0, L_sL = 0, F_l = 1, L_rW = 0, L_sW = F_w.0) 
# out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE))
# plot(out)
# out[dim(out)[1], ]
# # then take output from out and use to start new simulation state
# State = out[dim(out)[1], 2:8]; State["L_rF"] = 0.001 # can just add resistant lice
# # then run second half
# out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE, maxroot = 1000))
# plot(out) # what is happening when th.0 == 0?
# out_df <- as.data.frame(out)
# out_df$lpf <- out_df$L_rF + out_df$L_sF
# out_df$grow <- (out_df$lpf - lag(out_df$lpf)) > 0
# length(which(out_df$grow == FALSE)) # gives number of treatments
# attributes(out)$troot # gives number of times treatment was applied based --> can use for treatment cost post resistant entering

```

```{r heatmaps}

tr.vec <- seq(from = 0.6, to = 0.9, length.out = 5) # treatment effect --> might be interesting to also do with wild fish to see how threshold & wild fish interact
th.vec <- seq(from = 0.01, to = 1, length.out = 20) # threshold
Fprop_mat <- matrix(NA, nrow = length(th.vec), ncol = length(tr.vec))
Flice_mat <- matrix(NA, nrow = length(th.vec), ncol = length(tr.vec))
Wfish_mat <- matrix(NA, nrow = length(th.vec), ncol = length(tr.vec))
lossesF1_mat <- matrix(NA, nrow = length(th.vec), ncol = length(tr.vec))
# lossesF2_mat <- matrix(NA, nrow = length(th.vec), ncol = length(tr.vec))
treat_mat <- matrix(NA, nrow = length(th.vec), ncol = length(tr.vec))
Wlice_mat <- matrix(NA, nrow = length(th.vec), ncol = length(tr.vec))

pT <- 0.02 # per capita cost of treatment
pQ <- 0.002 # per capita loss due to parasite burden
pF <- 1 # per capita cost of fish (sale price)

# try with mapply??

for (i in 1:length(tr.vec)) {
  
  t_s.0 = tr.vec[i]
  t_r.0 = t_s.0*0.5 # make 25% of t_s

  for (j in 1:length(th.vec)) {

    th.0 = th.vec[j]
    
    rootfunc <- function(Time, y, Pars) {return (y[1] + y[2] - th.0*F_f.0)} # threshold hit
    eventfunc <- function(Time, y, Pars) {
  y[1] <- (1-t_r.0)*y[1]
  y[2] <- (1-t_s.0)*y[2]
  return(y)
} # at the root, do this event
    Pars = c(l_s = l_s.0, c_s = c_s.0, l_r = l_r.0, c_r = c_r.0, 
         u_s = u_s.0, u_r = u_r.0, m = m.0, mb = mb.0,
         p_ff = p_ff.0, p_ll = p_ll.0, p_fl = p_fl.0, p_lf = p_lf.0, p_ww = p_ww.0, 
         B_f = B_f.0, B_l = B_l.0, B_w = B_w.0,
         Tr = Tr.0, t_r = t_r.0, t_s = t_s.0, b = b.0, th = th.0, h = h.0,
         F_f = F_f.0, F_w = F_w.0, 
         r = r.0, v = v.0, X = X.0, Y = Y.0, u_f = u_f.0, sig = sig.0,
         M_out = M_out.0, M_in = M_in.0)
    
    State = c(L_rF = 0, L_sF = 0.001, L_rL = 0, L_sL = 0, F_l = 1, L_rW = 0, L_sW = 0.2)
    out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE))
    # then take output from out and use to start new simulation state
    State = out[dim(out)[1], 2:8]; State["L_sF"] = State["L_sF"]-0.001; State["L_rF"] = 0.001 # can just replace a suseptable louse with a resistant louse
    out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE))
    
    out_df <- as.data.frame(out)
    # out_df <- out_df %>% filter(time > n-50)
    out_df$lpff <- (out_df$L_rF + out_df$L_sF)/F_f.0
    out_df$grow <- (out_df$lpff - lag(out_df$lpff)) >= 0
    treat_apply <- ifelse(out_df$grow == TRUE, 0, 1)
    # sum(diff(out_df$grow[2:length(out_df$grow)]) == 1) + ifelse(out_df$grow[length(out_df$grow)] == FALSE, 1, 0)
    # length(which(out_df$grow == FALSE))  
    # corrections
    # treat_apply <- ifelse(treat_apply == 1, 0, treat_apply)
    # treat_apply <- ifelse(is.null(treat_apply), 0, treat_apply)
    out_df$resist <- out_df$L_rF/out_df$lpff
    out_df$lpfw <- (out_df$L_rW + out_df$L_sW)/F_w.0
    # out_df$losses <- pT*F_f.0*treat_apply + pQ*out_df$lpff # per capita costs for both
  
    # matrix updates --> grab last ten time steps to average over
    out_df2 <- out_df %>% filter(time > 140)
    # out_df3 <- out_df[c(seq(from = 10, to  = 1500, by = 10)), ] # only add in if harvest occurs --> here, every 10 time steps??
    Fprop_mat[j, i] <- mean(out_df2$resist)
    Flice_mat[j, i] <- mean(out_df2$lpff)
    Wfish_mat[j, i] <- mean(out_df2$F_l)
    treat_mat[j, i] <- sum(treat_apply, na.rm = TRUE)
    lossesF1_mat[j, i] <- pT*F_f.0*treat_mat[j, i] + sum(pQ*out_df$lpff) # number of times you applied treatment plus some cost per lice
    # lossesF2_mat[j, i] <- sum(out_df2$losses)
    Wlice_mat[j, i] <- mean(out_df2$lpfw)

  }
}

# for connectivbity, add 1:1 line
# heatmap(Fprop_mat, Colv = NA, Rowv = NA, scale = "none", add.expr = abline(0, 1))
heatmap(Fprop_mat, Colv = NA, Rowv = NA, scale = "none")
range(Fprop_mat)
heatmap(Flice_mat, Colv = NA, Rowv = NA, scale = "none")
range(Flice_mat)
heatmap(Wfish_mat, Colv = NA, Rowv = NA, scale = "none")
range(Wfish_mat)
heatmap(lossesF1_mat, Colv = NA, Rowv = NA, scale = "none")
range(lossesF1_mat)
heatmap(lossesF2_mat, Colv = NA, Rowv = NA, scale = "none")
range(lossesF2_mat)
heatmap(Wlice_mat, Colv = NA, Rowv = NA, scale = "none")
range(Wlice_mat)

```

```{r better plotting?}

FPM <- melt(Fprop_mat)
for (i in 1:dim(FPM)[1]) {
  FPM$Treat_Int[i] <- tr.vec[FPM$Var2[i]] # need to rename based on vectors
  FPM$Threshold[i] <- th.vec[FPM$Var1[i]] # need to rename based on vectors
}

ggplot(FPM %>% filter(Treat_Int < 1), aes(x = Treat_Int, y = Threshold)) + geom_tile(aes(fill = value)) + theme_bw() + scale_x_continuous(name = "Treatment Intensity") + scale_y_continuous(name = "Treatment Threshold") + scale_fill_distiller(palette = "YlOrRd", direction = 1, na.value="white", limits=c(0, 1), name = "Percent \nresistant") # Spectral  + scale_fill_distiller(palette = "YlOrRd", direction = 1, na.value="white", limits=c(0, 1), name = "Percent \nresistant")

ggplot(FPM %>% filter(Treat_Int < 1), aes(x = Treat_Int, y = Threshold)) + geom_tile(aes(fill = (value))) + theme_bw() + scale_x_continuous(name = "Treatment Effectivity") + scale_y_continuous(name = "Treatment Threshold") + scale_fill_viridis(option = "F", limits = c(0, 1), name = "Percent \nresistant", direction = -1) # also B

ggplot(NULL, aes(FPM$Threshold, FPM$value, color = FPM$Treat_Int)) + geom_point() + theme_bw() + scale_x_continuous(name = "Threshold") + scale_y_continuous(name = "Percent Resistant") + scale_color_viridis(option = "D", name = "Treatment \neffectivity", direction = -1)

pal <- pnw_palette("Sunset2",100) # Sunset2, Shuksan2
pal <- met.brewer("Troy",100) # Sunset2
pal <- met.brewer("Benedictus",100, direction = -1) # Sunset2
ggplot(FPM %>% filter(Treat_Int < 1), aes(x = Treat_Int, y = Threshold)) + geom_tile(aes(fill = (value))) + theme_bw() + scale_x_continuous(name = "Treatment Intensity") + scale_y_continuous(name = "Treatment Threshold") + scale_fill_gradientn(colours = pal, limits = c(0, 1), name = "Percent \nresistant") # Spectral  + scale_fill_distiller(palette = "YlOrRd", direction = 1, na.value="white", limits=c(0, 1), name = "Percent \nresistant")
ggplot(NULL, aes(FPM$Threshold, FPM$value, color = FPM$Treat_Int)) + geom_point() + theme_bw() + scale_x_continuous(name = "Threshold") + scale_y_continuous(name = "Percent Resistant") + scale_color_gradientn(colours = pal, limits = c(0, 1), name = "Treatment \neffectivity") # Tam, Homer2 is also nice for this one

```

```{r resistance v link population size}

FPM <- melt(Fprop_mat)
for (i in 1:dim(FPM)[1]) {
    FPM$Treat_Int[i] <- tr.vec[FPM$Var2[i]] # need to rename based on vectors
    FPM$Threshold[i] <- th.vec[FPM$Var1[i]] # need to rename based on vectors
}

WFM <- melt(Wfish_mat)
for (i in 1:dim(WFM)[1]) {
    WFM$Treat_Int[i] <- tr.vec[WFM$Var2[i]] # need to rename based on vectors
    WFM$Threshold[i] <- th.vec[WFM$Var1[i]] # need to rename based on vectors
}

FPM <- FPM %>% filter(Treat_Int < 1); WFM <- WFM %>% filter(Treat_Int < 1)

# ggplot(NULL, aes(FPM$value, WFM$value, color = FPM$Threshold)) + geom_point() + theme_bw() + scale_x_continuous(name = "Resistance") + scale_y_continuous(name = "Link Pop Size") + scale_color_viridis(option = "F", name = "Threshold", direction = -1)

ggplot(NULL, aes(FPM$Threshold, FPM$value, color = FPM$Treat_Int)) + geom_point(size = 1.8) + theme_bw() + scale_x_continuous(name = "Threshold") + scale_y_continuous(name = "Resistance") + scale_color_viridis(option = "D", name = "Treatment \nIntensity", direction = -1)

ggplot(NULL, aes(WFM$Threshold, WFM$value, color = WFM$Treat_Int)) + geom_point(size = 1.8) + theme_bw() + scale_x_continuous(name = "Threshold") + scale_y_continuous(name = "Link Population Size") + scale_color_viridis(option = "D", name = "Treatment \nIntensity", direction = -1)

# ggplot(NULL, aes(FPM$Threshold, WFM$value, color = FPM$value)) + geom_point() + theme_bw() + scale_x_continuous(name = "Treatment threshold") + scale_y_continuous(name = "Link Pop Size") + scale_color_viridis(option = "F", name = "Treatment \nIntensity", direction = -1)

FLM <- melt(lossesF1_mat)
for (i in 1:dim(FLM)[1]) {
    FLM$Treat_Int[i] <- tr.vec[FLM$Var2[i]] # need to rename based on vectors
    FLM$Threshold[i] <- th.vec[FLM$Var1[i]] # need to rename based on vectors
}
# FLM <- FLM %>% filter(Treat_Int < 1 & Treat_Int > 0.3)

ggplot(NULL, aes(FLM$Threshold, FLM$value, color = FLM$Treat_Int)) + geom_point(size = 1.8) + theme_bw() + scale_x_continuous(name = "Treatment threshold") + scale_y_continuous(name = "Farm losses") + scale_color_viridis(option = "D", name = "Treatment \nIntensity", direction = -1)

```

```{r one at a time}

fw.vec = seq(from = 0.5, to = 10, by = 0.5)
r.vec = seq(from = 0.5, to = 3, length.out = length(fw.vec))
resist.vec = rep(NA, length.out = length(fw.vec))
econ.vec = rep(NA, length.out = length(fw.vec))

for (i in 1:length(fw.vec)) {

    # F_w.0 = fw.vec[i]
    r.0 = r.vec[i]
    
    rootfunc <- function(Time, y, Pars) {return (y[1] + y[2] - th.0*F_f.0)}
    eventfunc <- function(Time, y, Pars) {
  y[1] <- (1-t_r.0)*y[1]
  y[2] <- (1-t_s.0)*y[2]
  return(y)
}
    Pars = c(l_s = l_s.0, c_s = c_s.0, l_r = l_r.0, c_r = c_r.0, 
         u_s = u_s.0, u_r = u_r.0, m = m.0, mb = mb.0,
         p_ff = p_ff.0, p_ll = p_ll.0, p_fl = p_fl.0, p_lf = p_lf.0, p_ww = p_ww.0, 
         B_f = B_f.0, B_l = B_l.0, B_w = B_w.0,
         Tr = Tr.0, t_r = t_r.0, t_s = t_s.0, b = b.0, th = th.0, h = h.0,
         F_f = F_f.0, F_w = F_w.0, 
         r = r.0, v = v.0, X = X.0, Y = Y.0, u_f = u_f.0, sig = sig.0,
         M_out = M_out.0, M_in = M_in.0)
    
    State = c(L_rF = 0, L_sF = 0.001, L_rL = 0, L_sL = 0, F_l = 1, L_rW = 0, L_sW = 0.2)
    out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE))
    # then take output from out and use to start new simulation state
    State = out[dim(out)[1], 2:8]; State["L_sF"] = State["L_sF"]-0.001; State["L_rF"] = 0.001 # can just replace a suseptable louse with a resistant louse
    out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE))
    
    out_df <- as.data.frame(out)
    out_df$lpff <- (out_df$L_rF + out_df$L_sF)/F_f.0
    out_df$grow <- (out_df$lpff - lag(out_df$lpff)) > 0
    treat_apply <- sum(diff(out_df$grow[2:length(out_df$grow)]) == 1) + ifelse(out_df$grow[length(out_df$grow)] == FALSE, 1, 0)
    # length(which(out_df$grow == FALSE))  
    # corrections
    treat_apply <- ifelse(treat_apply == 1, 0, treat_apply)
    treat_apply <- ifelse(is.null(treat_apply), 0, treat_apply)
    out_df$resist <- out_df$L_rF/out_df$lpff
    out_df$lpfw <- (out_df$L_rW + out_df$L_sW)/F_w.0
    # out_df$losses <- pT*F_f.0*treat_apply + pQ*out_df$lpff # per capita costs for both
  
    # matrix updates --> grab last ten time steps to average over
    out_df2 <- out_df %>% filter(time > 140)
    out_df3 <- out_df[c(seq(from = 10, to  = 1500, by = 10)), ] # only add in if harvest occurs --> here, every 10 time steps??
    
    # matrix updates --> grab last ten time steps to average over
    out_df2 <- out_df %>% filter(time > 140)
    out_df3 <- out_df[c(seq(from = 10, to  = 1500, by = 10)), ] # only add in if harvest occurs --> here, every 10 time steps??
    resist.vec[i] <- mean(out_df2$resist)
    econ.vec[i] <- pT*sum(length(treat_apply)) + sum(pQ*(out_df2$lpff))

}

plot(fw.vec, resist.vec)
plot(fw.vec, econ.vec)
plot(r.vec, resist.vec)
plot(r.vec, econ.vec)

ggplot(NULL, aes(fw.vec, resist.vec, col = econ.vec)) + geom_point(size = 3) + theme_bw() + scale_x_continuous(name = "Wild Fish Factor") + scale_y_continuous(name = "Percent Resistant") + scale_color_viridis(option = "D", name = "Farm \nlosses", direction = -1)

```

```{r figure 2: resistance evolution by managment choices}

# set up & make function
{# little axes
tr.vec <- seq(from = 0.2, to = 0.9, length.out = 5) # treatment effect --> might be interesting to also do with wild fish to see how threshold & wild fish interact
th.vec <- seq(from = 0.01, to = 18, length.out = 18) # threshold
Fprop_mat <- matrix(NA, nrow = length(th.vec), ncol = length(tr.vec))
# cols/rows
LC = 0.9; HC = 0.7
LW = 4; HW = 12

resist_dat <- function() {
  
  for (i in 1:length(tr.vec)) {
  
  t_s.0 = tr.vec[i]
  t_r.0 = t_s.0*0.25 # make 25% of t_s

  for (j in 1:length(th.vec)) {

    th.0 = th.vec[j]
    
    rootfunc <- function(Time, y, Pars) {return (y[1] + y[2] - th.0*F_f.0)} # threshold hit
    eventfunc <- function(Time, y, Pars) {
  y[1] <- (1-t_r.0)*y[1]
  y[2] <- (1-t_s.0)*y[2]
  return(y)
} # at the root, do this event
    Pars = c(l_s = l_s.0, c_s = c_s.0, l_r = l_r.0, c_r = c_r.0, 
         u_s = u_s.0, u_r = u_r.0, m = m.0, mb = mb.0,
         p_ff = p_ff.0, p_ll = p_ll.0, p_fl = p_fl.0, p_lf = p_lf.0, p_ww = p_ww.0, 
         B_f = B_f.0, B_l = B_l.0, B_w = B_w.0,
         Tr = Tr.0, t_r = t_r.0, t_s = t_s.0, b = b.0, th = th.0, h = h.0,
         F_f = F_f.0, F_w = F_w.0, 
         r = r.0, v = v.0, X = X.0, Y = Y.0, u_f = u_f.0, sig = sig.0,
         M_out = M_out.0, M_in = M_in.0)
    
    State = c(L_rF = 0, L_sF = 0.001, L_rL = 0, L_sL = 0, F_l = r.0, L_rW = 0, L_sW = F_w.0)
    out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE))
    # then take output from out and use to start new simulation state
    State = out[dim(out)[1], 2:8]; State["L_sF"] = State["L_sF"]-0.001; State["L_rF"] = 0.001 # can just replace a suseptable louse with a resistant louse
    out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE))
    
    out_df <- as.data.frame(out)
    out_df$lpff <- (out_df$L_rF + out_df$L_sF)/F_f.0
    out_df$resist <- out_df$L_rF/(out_df$L_rF + out_df$L_sF)

    # matrix updates --> grab last ten time steps to average over
    out_df2 <- out_df %>% filter(time > (n/2 - 30))
    # out_df3 <- out_df[c(seq(from = 10, to  = 1500, by = 10)), ] # only add in if harvest occurs --> here, every 10 time steps??
    Fprop_mat[j, i] <- mean(out_df2$resist)

  }
}
  
  FPM <- melt(Fprop_mat)
  for (i in 1:dim(FPM)[1]) {
    FPM$Treat_Int[i] <- tr.vec[FPM$Var2[i]] # need to rename based on vectors
    FPM$Threshold[i] <- th.vec[FPM$Var1[i]] # need to rename based on vectors
}
  
  return(FPM)
  
}}

# run across parameters
{p_ff.0 = LC; p_ll.0 = p_ff.0; p_fl.0 = 1-p_ff.0; p_lf.0 = p_fl.0; F_w.0 = LW*F_f.0
LCLW <- resist_dat()
p_ff.0 = HC; p_ll.0 = p_ff.0; p_fl.0 = 1-p_ff.0; p_lf.0 = p_fl.0; F_w.0 = LW*F_f.0
HCLW <- resist_dat()
p_ff.0 = LC; p_ll.0 = p_ff.0; p_fl.0 = 1-p_ff.0; p_lf.0 = p_fl.0; F_w.0 = HW*F_f.0
LCHW <- resist_dat()
p_ff.0 = HC; p_ll.0 = p_ff.0; p_fl.0 = 1-p_ff.0; p_lf.0 = p_fl.0; F_w.0 = HW*F_f.0
HCHW <- resist_dat()}

# make subplots
{LCLW_g <- ggplot(LCLW, aes(Threshold, value, color = Treat_Int)) + geom_point(size = 1.8) + theme_bw() + scale_x_continuous(name = NULL) + scale_y_continuous(name = "Resistance", limits = c(0, 1)) +  scale_color_viridis(option = "D", direction = -1, name = "Treatment \nEfficacy", limits = c(min(LCLW$Treat_Int), max(LCLW$Treat_Int)))
HCLW_g <- ggplot(NULL, aes(HCLW$Threshold, HCLW$value, color = HCLW$Treat_Int)) + geom_point(size = 1.8, show.legend = F) + theme_bw() + scale_x_continuous(NULL) + scale_y_continuous(name = NULL, limits = c(0, 1)) + scale_color_viridis(option = "D", direction = -1)
LCHW_g <- ggplot(NULL, aes(LCHW$Threshold, LCHW$value, color = LCHW$Treat_Int)) + geom_point(size = 1.8, show.legend = F) + theme_bw() + scale_x_continuous(name = "Threshold") + scale_y_continuous(name = "Resistance", limits = c(0, 1)) + scale_color_viridis(option = "D", direction = -1)
HCHW_g <- ggplot(NULL, aes(HCHW$Threshold, HCHW$value, color = HCHW$Treat_Int)) + geom_point(size = 1.8, show.legend = F) + theme_bw() + scale_x_continuous(name = "Threshold") + scale_y_continuous(NULL, limits = c(0, 1)) + scale_color_viridis(option = "D", direction = -1)}

# final plot
lgnd <- get_legend(
  LCLW_g + theme(legend.box.margin = margin(0, 0, 150, 6))
)

tmp <- plot_grid(LCLW_g+theme(legend.position="none"), 
          HCLW_g, 
          LCHW_g, 
          HCHW_g, 
          ncol = 2)

lab_vert <- ggdraw() + draw_label("Large refuge                     Small refuge", fontface = 'bold', x = 0, hjust = 0, angle = 90) + theme(plot.margin = margin(240, 10, 10, 10))
lab_hor <- ggdraw() + draw_label("Low connectivity                 High connectivity", fontface = 'bold', x = 0, hjust = 0) + theme(plot.margin = margin(0, 30, 10, 70))

fig2 <- plot_grid(tmp, lgnd, ncol = 2, rel_widths = c(3, .55))
fig2v <- plot_grid(lab_vert, fig2, ncol = 2, rel_widths = c(0.15, 3))
fig2_full <- plot_grid(lab_hor, fig2v, nrow = 2, rel_heights = c(0.2, 3))
png("plots/resistance_fig2.png",height=150,width=170,res=400,units='mm')
print(fig2_full)
dev.off()

```

```{r figure 3: resistance evolution by biological trade-off}

# set up & make function
{# little axes
ratio.vec <- seq(from = 0.05, to = 1, length.out = 40) # treatment effect --> might be interesting to also do with wild fish to see how threshold & wild fish interact
fecund.vec <- seq(from = 0.45, to = 1, length.out = 20) # threshold
Fprop_mat <- matrix(NA, nrow = length(fecund.vec), ncol = length(ratio.vec))
# cols/rows
EL = 0.6; EH = 0.9
th.0 = 3

cost_ben_dat <- function() {
  
  for (i in 1:length(ratio.vec)) {
  
  t_s.0 = EPI
  t_r.0 = t_s.0*ratio.vec[i]

  for (j in 1:length(fecund.vec)) {

    l_s.0 = 6.35
    l_r.0 = fecund.vec[j]*6.35
    
    rootfunc <- function(Time, y, Pars) {return (y[1] + y[2] - th.0*F_f.0)} # threshold hit
    eventfunc <- function(Time, y, Pars) {
  y[1] <- (1-t_r.0)*y[1]
  y[2] <- (1-t_s.0)*y[2]
  return(y)
} # at the root, do this event
    Pars = c(l_s = l_s.0, c_s = c_s.0, l_r = l_r.0, c_r = c_r.0, 
         u_s = u_s.0, u_r = u_r.0, m = m.0, mb = mb.0,
         p_ff = p_ff.0, p_ll = p_ll.0, p_fl = p_fl.0, p_lf = p_lf.0, p_ww = p_ww.0, 
         B_f = B_f.0, B_l = B_l.0, B_w = B_w.0,
         Tr = Tr.0, t_r = t_r.0, t_s = t_s.0, b = b.0, th = th.0, h = h.0,
         F_f = F_f.0, F_w = F_w.0, 
         r = r.0, v = v.0, X = X.0, Y = Y.0, u_f = u_f.0, sig = sig.0,
         M_out = M_out.0, M_in = M_in.0)
    
    State = c(L_rF = 0, L_sF = 0.001, L_rL = 0, L_sL = 0, F_l = r.0, L_rW = 0, L_sW = F_w.0)
    out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE))
    # then take output from out and use to start new simulation state
    State = out[dim(out)[1], 2:8]; State["L_sF"] = State["L_sF"]-0.001; State["L_rF"] = 0.001 # can just replace a suseptable louse with a resistant louse
    out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE))
    
    out_df <- as.data.frame(out)
    out_df$lpff <- (out_df$L_rF + out_df$L_sF)/F_f.0
    out_df$resist <- out_df$L_rF/(out_df$L_rF + out_df$L_sF)

    # matrix updates --> grab last ten time steps to average over
    out_df2 <- out_df %>% filter(time > (n/2 - 10))
    # out_df3 <- out_df[c(seq(from = 10, to  = 1500, by = 10)), ] # only add in if harvest occurs --> here, every 10 time steps??
    Fprop_mat[j, i] <- mean(out_df2$resist)

  }
}
  
  FPM <- melt(Fprop_mat)
  for (i in 1:dim(FPM)[1]) {
    FPM$Ratio[i] <- ratio.vec[FPM$Var2[i]] # need to rename based on vectors
    FPM$Fecund[i] <- fecund.vec[FPM$Var1[i]] # need to rename based on vectors
}
  
  return(FPM)
  
}
}

# reset from figure 2
p_ff.0 = 0.9; p_ll.0 = p_ff.0; p_fl.0 = 1-p_ff.0; p_lf.0 = p_fl.0; F_w.0 = 12*F_f.0
# run across parameters
EPI = EH; th.0 = 12
cost_ben <- cost_ben_dat()

# make plot
fig3 <- ggplot(cost_ben, aes(Fecund, Ratio, fill = value)) + geom_tile(height = ratio.vec[2]-ratio.vec[1], width = fecund.vec[2]-fecund.vec[1]) + theme_bw() + scale_x_continuous(name = "Fecundity Cost") + scale_y_continuous(name = "Treatment Erosion Benefit \n(resistant:suseptable \ntreatment efficacy)") +  scale_fill_viridis(option = "D", direction = -1, name = "Proportion\nResistant", limits = c(0, 1)) + geom_point(data = NULL, aes(0.9, 0.25), col = "white")
fig3
png("plots/resistance_fig3.png",height=170,width=170,res=400,units='mm')
print(fig3)
dev.off()

```

```{r NOW PART OF FIG 6 figure 4: economic outcomes}

# reset pars
p_ff.0 = 0.7; p_ll.0 = p_ff.0; p_fl.0 = 1-p_ff.0; p_lf.0 = p_fl.0; F_w.0 = 25*F_f.0; t_s.0 = 0.95; t_r.0 = t_s.0*0.25; l_s.0 = 6.35; l_r.0 = l_s.0*0.9

# set up & make function
{tr.vec <- seq(from = 0.2, to = 0.9, length.out = 5) # treatment effect --> might be interesting to also do with wild fish to see how threshold & wild fish interact
th.vec <- seq(from = 0.01, to = 18, length.out = 18) # threshold
lossesF1_mat <- matrix(NA, nrow = length(th.vec), ncol = length(tr.vec))

econ <- function() {
for (i in 1:length(tr.vec)) {
  
  t_s.0 = tr.vec[i]
  t_r.0 = t_s.0*0.25 # make 25% of t_s

  for (j in 1:length(th.vec)) {

    th.0 = th.vec[j]
    
    rootfunc <- function(Time, y, Pars) {return (y[1] + y[2] - th.0*F_f.0)} # threshold hit
    eventfunc <- function(Time, y, Pars) {
  y[1] <- (1-t_r.0)*y[1]
  y[2] <- (1-t_s.0)*y[2]
  return(y)
} # at the root, do this event
    
    Pars = c(l_s = l_s.0, c_s = c_s.0, l_r = l_r.0, c_r = c_r.0, 
         u_s = u_s.0, u_r = u_r.0, m = m.0, mb = mb.0,
         p_ff = p_ff.0, p_ll = p_ll.0, p_fl = p_fl.0, p_lf = p_lf.0, p_ww = p_ww.0, 
         B_f = B_f.0, B_l = B_l.0, B_w = B_w.0,
         Tr = Tr.0, t_r = t_r.0, t_s = t_s.0, b = b.0, th = th.0, h = h.0,
         F_f = F_f.0, F_w = F_w.0, 
         r = r.0, v = v.0, X = X.0, Y = Y.0, u_f = u_f.0, sig = sig.0,
         M_out = M_out.0, M_in = M_in.0)
    
    State = c(L_rF = 0, L_sF = 0.001, L_rL = 0, L_sL = 0, F_l = r.0, L_rW = 0, L_sW = F_w.0)
    out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE))
    # then take output from out and use to start new simulation state
    State = out[dim(out)[1], 2:8]; State["L_sF"] = State["L_sF"]-0.001; State["L_rF"] = 0.001 # can just replace a suseptable louse with a resistant louse
    out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE, maxroot = 6000))
    
    out_df <- as.data.frame(out)
    # out_df2 <- out_df %>% filter(time > (n/2)-30)
    # out_df$lpff <- (out_df$L_rF + out_df$L_sF)/F_f.0
    # out_df$grow <- (out_df$lpff - lag(out_df$lpff)) >= 0
    # treat_apply <- ifelse(out_df$grow == TRUE, 0, 1)
    treat_time <- attributes(out)$troot
    # treat_apply <- sum(treat_time > (n/2)-30, na.rm = TRUE)
    treat_apply <- length(attributes(out)$troot)

    # matrix updates --> grab last ten time steps to average over
    # treat_mat[j, i] <- sum(treat_apply, na.rm = TRUE)
    lossesF1_mat[j, i] <- pT*F_f.0*treat_apply + sum(pQ*(out_df$L_rF + out_df$L_sF)) # pT*F_f.0*treat_mat[j, i] + sum(pQ*out_df$lpff) # number of times you applied treatment plus some cost per lice

  }
}
  
  FLM <- melt(lossesF1_mat)
  for (i in 1:dim(FLM)[1]) {
    FLM$Treat_Int[i] <- tr.vec[FLM$Var2[i]] # need to rename based on vectors
    FLM$Threshold[i] <- th.vec[FLM$Var1[i]] # need to rename based on vectors
}
  
  return(FLM)
  
}}

# run across parameters
{pQ = 0.002; pT = 30*pQ
HTC <- econ()
pQ = 0.002; pT = 15*pQ
LTC <- econ()}

# make economic value standardized
{stand_val <- max(HTC$value, LTC$value)
HTC$econ <- HTC$value/stand_val
LTC$econ <- LTC$value/stand_val
}

# make subplots
{HTC_g <- ggplot(HTC, aes(Threshold, econ, color = Treat_Int)) + geom_hline(yintercept = HTC$econ[which(HTC$Threshold == 18)[1]], col = "darkgray", linetype=2) + geom_point(size = 1.8) + theme_bw() + scale_x_continuous(name = "Threshold") + scale_y_continuous(name = "Economic Losses (Standardized)", limits = c(0, 1)) +  scale_color_viridis(option = "D", direction = -1, name = "Treatment \nEfficacy", limits = c(0.2, 0.95)) 
LTC_g <- ggplot(NULL, aes(LTC$Threshold, LTC$econ, color = LTC$Treat_Int)) + geom_hline(yintercept = LTC$econ[which(HTC$Threshold == 18)[1]], col = "darkgray", linetype=2) + geom_point(size = 1.8, show.legend = F) + theme_bw() + scale_x_continuous("Threshold") + scale_y_continuous(name = NULL, limits = c(0, 1)) + scale_color_viridis(option = "D", direction = -1)}

# final plot
lgnd_econ <- get_legend(
  HTC_g + theme(legend.box.margin = margin(0, 0, 100, 6))
)

tmp_econ <- plot_grid(HTC_g+theme(legend.position="none"), 
          LTC_g,
          ncol = 2)

fig4 <- plot_grid(tmp_econ, lgnd_econ, ncol = 2, rel_widths = c(3, .55))
fig4
png("plots/resistance_fig4.png",height=85,width=170,res=400,units='mm')
print(fig4)
dev.off()

```

```{r figure 5: expendature frontiers w/base parameters}

# reset pars
p_ff.0 = 0.7; p_ll.0 = p_ff.0; p_fl.0 = 1-p_ff.0; p_lf.0 = p_fl.0; F_w.0 = 25*F_f.0; t_s.0 = 0.95; t_r.0 = t_s.0*0.25; l_s.0 = 6.35; l_r.0 = l_s.0*0.9

# run time vector
n = 365*5 # for daily bateman pars --> 10 years
Time = seq(0, n, length.out = n/2)
# since running twice

# run matrix
{tr.vec <- seq(from = 0.2, to = 0.9, length.out = 5) # treatment effect --> might be interesting to also do with wild fish to see how threshold & wild fish interact
th.vec <- seq(from = 0.01, to = 18, length.out = 18) # threshold
Fprop_mat <- matrix(NA, nrow = length(th.vec), ncol = length(tr.vec))
Wfish_mat <- matrix(NA, nrow = length(th.vec), ncol = length(tr.vec))
lossesF1_mat <- matrix(NA, nrow = length(th.vec), ncol = length(tr.vec))
treat_mat <- matrix(NA, nrow = length(th.vec), ncol = length(tr.vec))
LPFF_mat <- matrix(NA, nrow = length(th.vec), ncol = length(tr.vec))

pQ <- 0.002 # per capita loss due to parasite burden
pT <- 30*pQ # per capita cost of treatment
# pF <- 1 # per capita cost of fish (sale price)

for (i in 1:length(tr.vec)) {
  
  t_s.0 = tr.vec[i]
  t_r.0 = t_s.0*0.25 # make 25% of t_s

  for (j in 1:length(th.vec)) {

    th.0 = th.vec[j]
    
    rootfunc <- function(Time, y, Pars) {return (y[1] + y[2] - th.0*F_f.0)} # threshold hit
    eventfunc <- function(Time, y, Pars) {
  y[1] <- (1-t_r.0)*y[1]
  y[2] <- (1-t_s.0)*y[2]
  return(y)
} # at the root, do this event
    Pars = c(l_s = l_s.0, c_s = c_s.0, l_r = l_r.0, c_r = c_r.0, 
         u_s = u_s.0, u_r = u_r.0, m = m.0, mb = mb.0,
         p_ff = p_ff.0, p_ll = p_ll.0, p_fl = p_fl.0, p_lf = p_lf.0, p_ww = p_ww.0, 
         B_f = B_f.0, B_l = B_l.0, B_w = B_w.0,
         Tr = Tr.0, t_r = t_r.0, t_s = t_s.0, b = b.0, th = th.0, h = h.0,
         F_f = F_f.0, F_w = F_w.0, 
         r = r.0, v = v.0, X = X.0, Y = Y.0, u_f = u_f.0, sig = sig.0,
         M_out = M_out.0, M_in = M_in.0)
    
    State = c(L_rF = 0, L_sF = 0.001, L_rL = 0, L_sL = 0, F_l = 1, L_rW = 0, L_sW = 0.2)
    out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE))
    # then take output from out and use to start new simulation state
    State = out[dim(out)[1], 2:8]; State["L_sF"] = State["L_sF"]-0.001; State["L_rF"] = 0.001 # can just replace a suseptable louse with a resistant louse
    out <- ode(Time, y = State, func = systemTREAT, parms = Pars, rootfun = rootfunc, events = list(func = eventfunc, root = TRUE, maxroot = 6000))
    
    out_df <- as.data.frame(out)
    # out_df$lpff <- (out_df$L_rF + out_df$L_sF)/F_f.0
    # treat_time <- attributes(out)$troot
    # treat_apply <- sum(treat_time > (n/2)-30, na.rm = TRUE)
    # out_df$grow <- (out_df$lpff - lag(out_df$lpff)) >= 0
    treat_apply <- length(attributes(out)$troot) # ifelse(out_df$grow == TRUE, 0, 1)
    out_df$resist <- out_df$L_rF/(out_df$L_rF + out_df$L_sF)

    # matrix updates --> grab last thirty time steps (month) to average over
    out_df2 <- out_df %>% filter(time > ((n/2) - 30))
    Fprop_mat[j, i] <- mean(out_df2$resist)
    Wfish_mat[j, i] <- mean(out_df2$F_l)
    # treat_mat[j, i] <- sum(treat_apply, na.rm = TRUE)
    lossesF1_mat[j, i] <- pT*F_f.0*treat_apply + sum(pQ*(out_df$L_rF + out_df$L_sF)) # pT*F_f.0*treat_mat[j, i] + sum(pQ*out_df$lpff) # number of times you applied treatment plus some cost per lice
    LPFF_mat[j, i] <- mean((out_df2$L_rF + out_df2$L_sF)/F_f.0)

  }
}}

# melt & standardize
{FPM <- melt(Fprop_mat)
for (i in 1:dim(FPM)[1]) {
    FPM$Treat_Int[i] <- tr.vec[FPM$Var2[i]] # need to rename based on vectors
    FPM$Threshold[i] <- th.vec[FPM$Var1[i]] # need to rename based on vectors
}

WFM <- melt(Wfish_mat)
for (i in 1:dim(WFM)[1]) {
    WFM$Treat_Int[i] <- tr.vec[WFM$Var2[i]] # need to rename based on vectors
    WFM$Threshold[i] <- th.vec[WFM$Var1[i]] # need to rename based on vectors
}
WFM$stand_fish <- WFM$value/max(WFM$value)

FLM <- melt(lossesF1_mat)
for (i in 1:dim(FLM)[1]) {
    FLM$Treat_Int[i] <- tr.vec[FLM$Var2[i]] # need to rename based on vectors
    FLM$Threshold[i] <- th.vec[FLM$Var1[i]] # need to rename based on vectors
}
FLM$stand_econ <- FLM$value/max(FLM$value)

FLF <- melt(LPFF_mat)
for (i in 1:dim(FLM)[1]) {
    FLF$Treat_Int[i] <- tr.vec[FLF$Var2[i]] # need to rename based on vectors
    FLF$Threshold[i] <- th.vec[FLF$Var1[i]] # need to rename based on vectors
} 

}

# get the values for expendature frontier
{# for economic, it's the Treat_Int == 0.9 + all the values when stand_fish == 1 (Threshold == 0.01)
econ_fish_dat <- merge(FLM, WFM, by = c("Threshold", "Treat_Int"))
econ_fish_front_0.9 <- econ_fish_dat %>% filter(Treat_Int == max(Treat_Int)) 
econ_fish_front_0.01 <- econ_fish_dat %>% filter(Threshold == 0.01) 
# for resistance, it's the Treat_Int == 0.6 plus the one extra
resist_fish_dat <- merge(FPM, WFM, by = c("Threshold", "Treat_Int"))
resist_fish_front <- resist_fish_dat %>% filter(Treat_Int == min(Treat_Int))
# insert extra point -- will need to watch for...
# ex_th <- th.vec[15]; ex_tr <- tr.vec[2]
# ex_row <- resist_fish_dat %>% filter(Treat_Int == ex_tr) %>% filter(Threshold == ex_th)
# resist_fish_front <- rbind(resist_fish_front, ex_row) 
}

# subplots
{econ_fish <- ggplot(econ_fish_dat, aes(stand_fish, -stand_econ, color = Treat_Int)) + geom_line(data = econ_fish_front_0.9, aes(stand_fish, -stand_econ), col = "darkgray") + geom_line(data = econ_fish_front_0.01, aes(stand_fish, -stand_econ), col = "darkgray") + geom_point(size = 1.8) + theme_bw() + scale_x_continuous(name = "Link Populaiton Size (Standardized)") + scale_y_continuous(name = "Negative Economic Losses (Standardized)") + scale_color_viridis(option = "D", name = "Treatment \nIntensity", direction = -1)
resist_fish <- ggplot(NULL, aes(WFM$stand_fish, -FPM$value, color = FLM$Treat_Int)) +  geom_line(data = resist_fish_front, aes(stand_fish, -value.x), col = "darkgray") + geom_point(size = 1.8) + geom_point(size = 1.8, data = (resist_fish_front %>% filter(Threshold == 0.01 | Threshold == 1)), aes(stand_fish, -value.x, color = Treat_Int)) + theme_bw() + scale_x_continuous(name = "Link Populaiton Size (Standardized)") + scale_y_continuous(name = "Negative Proportion Resistant") + scale_color_viridis(option = "D", direction = -1)}

lgnd <- get_legend(
  econ_fish + theme(legend.box.margin = margin(0, 0, 100, 6))
)

tmp_fronts <- plot_grid(econ_fish+theme(legend.position="none"), 
          resist_fish+theme(legend.position="none"),
          ncol = 2)

fig5 <- plot_grid(tmp_fronts, lgnd, ncol = 2, rel_widths = c(3, .55))
fig5
png("plots/resistance_fig5.png",height=85,width=170,res=400,units='mm')
print(fig5)
dev.off() 

```

```{r outcomes across thresholds}

# view across thresholds
{wf <- ggplot(NULL, aes(WFM$Threshold, WFM$value/max(WFM$value), color = WFM$Treat_Int)) + geom_vline(xintercept = 3, linetype = 2) + geom_point(size = 1.8) + theme_bw() + scale_x_continuous(name = "Threshold") + scale_y_continuous(name = "Link Populaiton Size (Standardized)") + scale_color_viridis(option = "D", direction = -1, name = "Treament \nIntensity") + coord_cartesian(ylim = c(0, 1))
rp <- ggplot(NULL, aes(FPM$Threshold, -FPM$value, color = FPM$Treat_Int)) + geom_vline(xintercept = 3, linetype = 2) + geom_point(size = 1.8) + theme_bw() + scale_x_continuous(name = "Threshold") + scale_y_continuous(name = "Negative Proportion Resistant") + scale_color_viridis(option = "D", direction = -1) + coord_cartesian(ylim = c(-1, 0))
fl <- ggplot(NULL, aes(FLM$Threshold, -FLM$value/max(FLM$value), color = FLM$Treat_Int)) + geom_vline(xintercept = 3, linetype = 3) + geom_point(size = 1.8) + theme_bw() + scale_x_continuous(name = "Threshold") + scale_y_continuous(name = "Negative Economic Losses (Standardized)") + scale_color_viridis(option = "D", direction = -1) + coord_cartesian(ylim = c(-1, 0))}

lgnd <- get_legend(
  wf + theme(legend.box.margin = margin(0, 0, 100, 6))
)

tmp_threshold <- plot_grid(wf+theme(legend.position="none"), 
          rp+theme(legend.position="none"),
          fl+theme(legend.position="none"),
          ncol = 3)

fig6 <- plot_grid(tmp_threshold, lgnd, ncol = 2, rel_widths = c(3, .55))
fig6
png("plots/resistance_fig6.png",height=85,width=170,res=400,units='mm')
print(fig6)
dev.off()

```

```{r farm burden link size}

# view across thresholds
{wfs <- ggplot(WFM %>% filter(Treat_Int %in% c(0.2, 0.9)), aes(Threshold, value, color = as.factor(Treat_Int))) + geom_vline(xintercept = 3, linetype = 2) + geom_point(size = 1.8) + theme_bw() + scale_x_continuous(name = "Threshold") + scale_y_continuous(name = "Avg. Link Populaiton Size") + scale_color_viridis(option = "D", direction = -1, name = "Treament \nIntensity", discrete = T)
flf <- ggplot(FLF %>% filter(Treat_Int %in% c(0.2, 0.9)), aes(Threshold, value, color = as.factor(Treat_Int))) + geom_vline(xintercept = 3, linetype = 2) + geom_point(size = 1.8) + theme_bw() + scale_x_continuous(name = "Threshold") + scale_y_continuous(name = "Avg. Farm Burden") + scale_color_viridis(option = "D", direction = -1, name = "Treament \nIntensity", discrete = T)}

lgnd <- get_legend(
  wfs + theme(legend.box.margin = margin(0, 0, 100, 6))
)

tmp_threshold <- plot_grid(wfs+theme(legend.position="none"), 
          flf+theme(legend.position="none"),
          ncol = 1)

fig7 <- plot_grid(tmp_threshold, lgnd, ncol = 2, rel_widths = c(2, .55))
fig7
png("plots/resistance_fig7.png",height=170,width=170,res=400,units='mm')
print(fig7)
dev.off()
# flipping points at ~10-12 is because of low resistance evolution = more effective treatment on average

# alt is: ggplot(NULL, aes(sm_FLF$value, sm_WFM$value, col = as.factor(sm_FLF$Treat_Int))) + geom_point()

```
